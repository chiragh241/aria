"""Config writer that generates settings.yaml and .env from wizard state."""

from __future__ import annotations

import shutil
from datetime import datetime
from pathlib import Path
from typing import TYPE_CHECKING, Any

import yaml

if TYPE_CHECKING:
    from src.cli.wizard import WizardState


class ConfigWriter:
    """Generates configuration files from wizard state."""

    def __init__(self, state: WizardState, project_root: Path | None = None):
        self.state = state
        self.root = project_root or Path(".")
        self.config_dir = self.root / "config"
        self.data_dir = self.root / "data"

    def write_all(self) -> list[str]:
        """Write all configuration files. Returns list of written file paths."""
        written: list[str] = []

        # Ensure directories exist
        self.config_dir.mkdir(parents=True, exist_ok=True)
        self.data_dir.mkdir(parents=True, exist_ok=True)

        # Back up existing files
        self._backup_if_exists(self.config_dir / "settings.yaml")
        self._backup_if_exists(self.root / ".env")

        # Write settings.yaml
        settings_path = self.config_dir / "settings.yaml"
        self._write_settings_yaml(settings_path)
        written.append(str(settings_path))

        # Write .env
        env_path = self.root / ".env"
        self._write_env(env_path)
        written.append(str(env_path))

        # Write sentinel file
        sentinel = self.data_dir / ".aria_configured"
        sentinel.write_text(
            f"configured_at: {datetime.now().isoformat()}\n"
            f"version: 0.1.0\n"
        )
        written.append(str(sentinel))

        return written

    # ── settings.yaml ──────────────────────────────────────────────────────

    def _write_settings_yaml(self, path: Path) -> None:
        """Generate and write the settings.yaml file."""
        config = self._build_settings_dict()

        header = (
            "# Aria Personal AI Agent Configuration\n"
            f"# Generated by setup wizard on {datetime.now().strftime('%Y-%m-%d %H:%M')}\n"
            "# Edit manually or re-run: python -m src.main --setup\n\n"
        )

        with open(path, "w") as f:
            f.write(header)
            yaml.dump(config, f, default_flow_style=False, sort_keys=False, allow_unicode=True)

    def _build_settings_dict(self) -> dict[str, Any]:
        """Build the full settings dictionary from wizard state."""
        s = self.state
        config: dict[str, Any] = {}

        # aria
        config["aria"] = {
            "name": "Aria",
            "version": "0.1.0",
            "data_dir": "./data",
            "deployment_mode": s.deployment_mode,
        }

        # llm
        config["llm"] = self._build_llm_config()

        # channels
        config["channels"] = self._build_channels_config()

        # security
        config["security"] = {
            "active_profile": s.security_profile,
            "approval_timeout": 300,
            "approval_channels": self._build_approval_channels(),
            "require_all_approvals": False,
        }

        # sandbox
        config["sandbox"] = self._build_sandbox_config()

        # memory
        config["memory"] = {
            "short_term": {"max_messages": 50, "max_tokens": 8000},
            "long_term": {
                "provider": "chromadb",
                "persist_directory": "./data/chromadb",
                "collection_name": "aria_memory",
                "embedding_model": "all-MiniLM-L6-v2",
            },
            "episodic": {"max_episodes": 1000, "summary_threshold": 10},
        }

        # database
        config["database"] = {
            "url": "sqlite+aiosqlite:///./data/aria.db",
            "echo": False,
        }

        # redis
        config["redis"] = {"enabled": False, "url": "redis://localhost:6379/0"}

        # logging
        config["logging"] = {
            "level": "INFO",
            "format": "json",
            "file": "./data/logs/aria.log",
            "max_size_mb": 100,
            "backup_count": 5,
            "audit_file": "./data/logs/audit.log",
        }

        # skills
        config["skills"] = self._build_skills_config()

        # dashboard
        config["dashboard"] = {
            "title": "Aria Control Center",
            "theme": "dark",
            "features": {
                "chat": True,
                "approvals": True,
                "settings": True,
                "logs": True,
                "skills": True,
                "metrics": True,
            },
        }

        return config

    def _build_llm_config(self) -> dict[str, Any]:
        """Build LLM configuration section."""
        s = self.state
        llm: dict[str, Any] = {}

        # Local LLM
        local_enabled = s.llm_provider in ("ollama", "hybrid") and s.ollama_enabled
        llm["local"] = {
            "provider": "ollama",
            "model": s.ollama_model,
            "base_url": s.ollama_base_url,
            "timeout": 60,
            "enabled": local_enabled,
        }

        # Cloud LLM
        cloud_enabled = s.llm_provider in ("anthropic", "hybrid")
        llm["cloud"] = {
            "provider": "anthropic",
            "model": s.anthropic_model,
            "max_tokens": 4096,
            "timeout": 120,
            "enabled": cloud_enabled,
        }

        # Routing
        llm["routing"] = {
            "simple_threshold": 50,
            "always_cloud": [
                "code_generation",
                "complex_reasoning",
                "skill_creation",
                "multi_step_planning",
            ],
            "fallback_to_cloud": cloud_enabled,
        }

        return llm

    def _build_channels_config(self) -> dict[str, Any]:
        """Build channels configuration section."""
        s = self.state
        channels: dict[str, Any] = {}

        # Slack
        channels["slack"] = {
            "enabled": s.channels_slack,
            "bot_token": "${SLACK_BOT_TOKEN}",
            "app_token": "${SLACK_APP_TOKEN}",
            "allowed_channels": [],
        }

        # WhatsApp
        channels["whatsapp"] = {
            "enabled": s.channels_whatsapp,
            "session_path": "./data/whatsapp-session",
            "bridge_port": s.whatsapp_bridge_port,
            "bridge_host": "localhost",
            "allowed_numbers": s.whatsapp_allowed_numbers,
        }

        # Web
        channels["web"] = {
            "enabled": True,
            "host": "0.0.0.0",
            "port": s.dashboard_port,
            "jwt_secret": "${JWT_SECRET}",
            "jwt_expiry_hours": 24,
        }

        return channels

    def _build_sandbox_config(self) -> dict[str, Any]:
        """Build sandbox configuration section."""
        s = self.state
        sandbox: dict[str, Any] = {
            "default": "docker" if s.sandbox_mode == "docker" else "direct",
        }

        sandbox["docker"] = {
            "image": "aria-sandbox:latest",
            "memory_limit": s.docker_memory,
            "cpu_limit": s.docker_cpu,
            "network_mode": "none",
            "timeout": 300,
        }

        sandbox["trusted_paths"] = s.trusted_paths
        sandbox["safe_commands"] = ["ls", "pwd", "whoami", "date", "echo"]

        return sandbox

    def _build_skills_config(self) -> dict[str, Any]:
        """Build skills configuration section."""
        s = self.state

        builtin: dict[str, Any] = {
            "filesystem": {
                "enabled": "filesystem" in s.enabled_skills,
                "max_file_size_mb": 100,
            },
            "shell": {
                "enabled": "shell" in s.enabled_skills,
                "timeout": 60,
            },
            "browser": {
                "enabled": "browser" in s.enabled_skills,
                "headless": True,
                "timeout": 30,
            },
            "calendar": {"enabled": "calendar" in s.enabled_skills},
            "email": {"enabled": "email" in s.enabled_skills},
            "sms": {"enabled": "sms" in s.enabled_skills},
            "tts": {
                "enabled": "tts" in s.enabled_skills,
                "provider": "edge-tts",
                "voice": "en-US-AriaNeural",
            },
            "stt": {
                "enabled": "stt" in s.enabled_skills,
                "provider": "whisper",
                "model": "base",
            },
            "image": {"enabled": "image" in s.enabled_skills},
            "video": {
                "enabled": "video" in s.enabled_skills,
                "ffmpeg_path": "ffmpeg",
            },
            "documents": {"enabled": "documents" in s.enabled_skills},
        }

        return {
            "builtin": builtin,
            "learned": {
                "enabled": True,
                "directory": "./data/learned_skills",
                "auto_test": True,
                "require_approval": True,
            },
        }

    def _build_approval_channels(self) -> list[str]:
        """Build list of approval channels based on enabled channels."""
        channels = ["web"]
        if self.state.channels_slack:
            channels.append("slack")
        if self.state.channels_whatsapp:
            channels.append("whatsapp")
        return channels

    # ── .env ───────────────────────────────────────────────────────────────

    def _write_env(self, path: Path) -> None:
        """Generate and write the .env file."""
        s = self.state
        lines = [
            "# Aria Environment Variables",
            f"# Generated by setup wizard on {datetime.now().strftime('%Y-%m-%d %H:%M')}",
            "",
        ]

        # LLM
        lines.append("# LLM Configuration")
        if s.llm_provider in ("ollama", "hybrid"):
            lines.append(f"OLLAMA_HOST={s.ollama_base_url}")

        if s.anthropic_api_key:
            lines.append(f"ANTHROPIC_API_KEY={s.anthropic_api_key}")
        else:
            lines.append("# ANTHROPIC_API_KEY=")
        lines.append("")

        # Web Dashboard
        lines.append("# Web Dashboard")
        lines.append(f"JWT_SECRET={s.jwt_secret}")
        lines.append(f"ADMIN_PASSWORD={s.admin_password}")
        lines.append(f"WEB_HOST=0.0.0.0")
        lines.append(f"WEB_PORT={s.dashboard_port}")
        lines.append("")

        # Slack
        if s.channels_slack:
            lines.append("# Slack")
            lines.append(f"SLACK_BOT_TOKEN={s.slack_bot_token}")
            lines.append(f"SLACK_APP_TOKEN={s.slack_app_token}")
            lines.append("")

        # Brave API
        if s.brave_api_key:
            lines.append("# Brave Search API")
            lines.append(f"BRAVE_API_KEY={s.brave_api_key}")
            lines.append("")

        # Data
        lines.append("# Data")
        lines.append("DATA_DIR=./data")
        lines.append("CHROMADB_PATH=./data/chromadb")
        lines.append("LOG_FILE=./data/logs/aria.log")
        lines.append("")

        # Security
        lines.append("# Security")
        lines.append(f"SECURITY_PROFILE={s.security_profile}")
        lines.append("APPROVAL_TIMEOUT=300")
        lines.append("")

        # Logging
        lines.append("# Logging")
        lines.append("LOG_LEVEL=INFO")
        lines.append("")

        path.write_text("\n".join(lines))

    # ── Helpers ─────────────────────────────────────────────────────────────

    @staticmethod
    def _backup_if_exists(path: Path) -> None:
        """Create a timestamped backup of an existing file."""
        if path.exists():
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup = path.with_suffix(f".{timestamp}.bak")
            shutil.copy2(path, backup)
